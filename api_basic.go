
/*
 * 共通資料-行政區
 *
 *  --- ##### API線上說明(Swagger UI)使用流程與注意事項： 1. 若不使用API金鑰呼叫API，則僅能透過瀏覽器呼叫`【基礎】`服務 ，且每個呼叫來源端IP的上限為每日50次。 2. `【進階】`、`【加值】`、`【歷史】`、`【MaaS】`服務需加入會員並取得API金鑰之後才能使用。 3. 欲使用API金鑰呼叫API，需[註冊為TDX會員](/register)，並於會員中心取得API金鑰。 4. 註冊為會員之後，至[【會員專區-資料服務-服務金鑰】](/user/dataservice/key)功能頁面，從預設金鑰(或建立新的金鑰)取得Client Id和Client Secret資訊。 5. 點選Swagger UI上的Authorize按鈕，依指示填入Client Id和Client Secret資訊並進行驗證，驗證完成後可開始於Swagger UI使用API。 6. 欲透過程式介接API，可參考[範例程式](https://github.com/tdxmotc/SampleCode)。 7. 為確保系統資源使用的合理分配與避免遭受濫用，於Swagger UI上使用API與程式介接API的行為將被記錄並定期做檢視。  ##### API呼叫次數限制: 1. 若不使用API金鑰呼叫API，則僅能透過瀏覽器呼叫`【基礎】`服務 ，且每個呼叫來源端IP的上限為每日50次。 2. 使用API金鑰呼叫API，每個呼叫來源端IP呼叫次數限制為50次/秒 (無每日上限)。  API OAS文本 :[請點我](https://tdx.transportdata.tw/webapi/File/Swagger/V3/152a47cc-4852-4fb0-93d3-9bb9db3811bd)
 *
 * API version: v2
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type BasicApiService service
/*
BasicApiService 取得[縣市]之City列表
取得[縣市]之City列表
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param format 指定來源格式
 * @param optional nil or *BasicApiBasicGetCityOpts - Optional Parameters:
     * @param "Select_" (optional.String) -  挑選
     * @param "Filter" (optional.String) -  過濾
     * @param "Orderby" (optional.String) -  排序
     * @param "Top" (optional.Int32) -  取前幾筆
     * @param "Skip" (optional.Int32) -  跳過前幾筆
@return ArrayOfCity
*/

type BasicApiBasicGetCityOpts struct {
    Select_ optional.String
    Filter optional.String
    Orderby optional.String
    Top optional.Int32
    Skip optional.Int32
}

func (a *BasicApiService) BasicGetCity(ctx context.Context, format string, localVarOptionals *BasicApiBasicGetCityOpts) (ArrayOfCity, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ArrayOfCity
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v2/Basic/City"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Select_.IsSet() {
		localVarQueryParams.Add("$select", parameterToString(localVarOptionals.Select_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Filter.IsSet() {
		localVarQueryParams.Add("$filter", parameterToString(localVarOptionals.Filter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Orderby.IsSet() {
		localVarQueryParams.Add("$orderby", parameterToString(localVarOptionals.Orderby.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Top.IsSet() {
		localVarQueryParams.Add("$top", parameterToString(localVarOptionals.Top.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Skip.IsSet() {
		localVarQueryParams.Add("$skip", parameterToString(localVarOptionals.Skip.Value(), ""))
	}
	localVarQueryParams.Add("$format", parameterToString(format, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ArrayOfCity
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
BasicApiService 取得指定[縣市(City)]之鄉鎮市區列表
取得指定[縣市(City)]之鄉鎮市區列表&lt;br /&gt;  TownCode以內政部戶政司制定代碼之前7碼作為鄉鎮市區之唯一代碼。第8碼原則為0，完整8碼請至內政部戶政司網站( https://www.ris.gov.tw/app/portal/164 )戶役政資料代碼內容查詢。
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param city 縣市(英文)&lt;br&gt;Taipei &#x3D; 臺北市, &lt;br&gt;Taichung &#x3D; 臺中市, &lt;br&gt;Keelung &#x3D; 基隆市, &lt;br&gt;Tainan &#x3D; 臺南市, &lt;br&gt;Kaohsiung &#x3D; 高雄市, &lt;br&gt;NewTaipei &#x3D; 新北市, &lt;br&gt;YilanCounty &#x3D; 宜蘭縣, &lt;br&gt;Taoyuan &#x3D; 桃園市, &lt;br&gt;Chiayi &#x3D; 嘉義市, &lt;br&gt;HsinchuCounty &#x3D; 新竹縣, &lt;br&gt;MiaoliCounty &#x3D; 苗栗縣, &lt;br&gt;NantouCounty &#x3D; 南投縣, &lt;br&gt;ChanghuaCounty &#x3D; 彰化縣, &lt;br&gt;Hsinchu &#x3D; 新竹市, &lt;br&gt;YunlinCounty &#x3D; 雲林縣, &lt;br&gt;ChiayiCounty &#x3D; 嘉義縣, &lt;br&gt;PingtungCounty &#x3D; 屏東縣, &lt;br&gt;HualienCounty &#x3D; 花蓮縣, &lt;br&gt;TaitungCounty &#x3D; 臺東縣, &lt;br&gt;KinmenCounty &#x3D; 金門縣, &lt;br&gt;PenghuCounty &#x3D; 澎湖縣, &lt;br&gt;LienchiangCounty &#x3D; 連江縣
 * @param format 指定來源格式
 * @param optional nil or *BasicApiBasicGetCityTownOpts - Optional Parameters:
     * @param "Select_" (optional.String) -  挑選
     * @param "Filter" (optional.String) -  過濾
     * @param "Orderby" (optional.String) -  排序
     * @param "Top" (optional.Int32) -  取前幾筆
     * @param "Skip" (optional.Int32) -  跳過前幾筆
@return ArrayOfTown
*/

type BasicApiBasicGetCityTownOpts struct {
    Select_ optional.String
    Filter optional.String
    Orderby optional.String
    Top optional.Int32
    Skip optional.Int32
}

func (a *BasicApiService) BasicGetCityTown(ctx context.Context, city string, format string, localVarOptionals *BasicApiBasicGetCityTownOpts) (ArrayOfTown, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ArrayOfTown
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v2/Basic/City/{City}/Town"
	localVarPath = strings.Replace(localVarPath, "{"+"City"+"}", fmt.Sprintf("%v", city), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Select_.IsSet() {
		localVarQueryParams.Add("$select", parameterToString(localVarOptionals.Select_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Filter.IsSet() {
		localVarQueryParams.Add("$filter", parameterToString(localVarOptionals.Filter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Orderby.IsSet() {
		localVarQueryParams.Add("$orderby", parameterToString(localVarOptionals.Orderby.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Top.IsSet() {
		localVarQueryParams.Add("$top", parameterToString(localVarOptionals.Top.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Skip.IsSet() {
		localVarQueryParams.Add("$skip", parameterToString(localVarOptionals.Skip.Value(), ""))
	}
	localVarQueryParams.Add("$format", parameterToString(format, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ArrayOfTown
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
BasicApiService 取得指定[縣市(City)]之村里列表
取得指定[縣市(City)]之村里列表
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param city 縣市(英文)&lt;br&gt;Taipei &#x3D; 臺北市, &lt;br&gt;Taichung &#x3D; 臺中市, &lt;br&gt;Keelung &#x3D; 基隆市, &lt;br&gt;Tainan &#x3D; 臺南市, &lt;br&gt;Kaohsiung &#x3D; 高雄市, &lt;br&gt;NewTaipei &#x3D; 新北市, &lt;br&gt;YilanCounty &#x3D; 宜蘭縣, &lt;br&gt;Taoyuan &#x3D; 桃園市, &lt;br&gt;Chiayi &#x3D; 嘉義市, &lt;br&gt;HsinchuCounty &#x3D; 新竹縣, &lt;br&gt;MiaoliCounty &#x3D; 苗栗縣, &lt;br&gt;NantouCounty &#x3D; 南投縣, &lt;br&gt;ChanghuaCounty &#x3D; 彰化縣, &lt;br&gt;Hsinchu &#x3D; 新竹市, &lt;br&gt;YunlinCounty &#x3D; 雲林縣, &lt;br&gt;ChiayiCounty &#x3D; 嘉義縣, &lt;br&gt;PingtungCounty &#x3D; 屏東縣, &lt;br&gt;HualienCounty &#x3D; 花蓮縣, &lt;br&gt;TaitungCounty &#x3D; 臺東縣, &lt;br&gt;KinmenCounty &#x3D; 金門縣, &lt;br&gt;PenghuCounty &#x3D; 澎湖縣, &lt;br&gt;LienchiangCounty &#x3D; 連江縣
 * @param format 指定來源格式
 * @param optional nil or *BasicApiBasicGetCityVillageOpts - Optional Parameters:
     * @param "Select_" (optional.String) -  挑選
     * @param "Filter" (optional.String) -  過濾
     * @param "Orderby" (optional.String) -  排序
     * @param "Top" (optional.Int32) -  取前幾筆
     * @param "Skip" (optional.Int32) -  跳過前幾筆
@return ArrayOfVillage
*/

type BasicApiBasicGetCityVillageOpts struct {
    Select_ optional.String
    Filter optional.String
    Orderby optional.String
    Top optional.Int32
    Skip optional.Int32
}

func (a *BasicApiService) BasicGetCityVillage(ctx context.Context, city string, format string, localVarOptionals *BasicApiBasicGetCityVillageOpts) (ArrayOfVillage, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ArrayOfVillage
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v2/Basic/City/{City}/Village"
	localVarPath = strings.Replace(localVarPath, "{"+"City"+"}", fmt.Sprintf("%v", city), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Select_.IsSet() {
		localVarQueryParams.Add("$select", parameterToString(localVarOptionals.Select_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Filter.IsSet() {
		localVarQueryParams.Add("$filter", parameterToString(localVarOptionals.Filter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Orderby.IsSet() {
		localVarQueryParams.Add("$orderby", parameterToString(localVarOptionals.Orderby.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Top.IsSet() {
		localVarQueryParams.Add("$top", parameterToString(localVarOptionals.Top.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Skip.IsSet() {
		localVarQueryParams.Add("$skip", parameterToString(localVarOptionals.Skip.Value(), ""))
	}
	localVarQueryParams.Add("$format", parameterToString(format, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ArrayOfVillage
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
BasicApiService 取得[縣市]之County列表
取得[縣市]之County列表
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param format 指定來源格式
 * @param optional nil or *BasicApiBasicGetCountyOpts - Optional Parameters:
     * @param "Select_" (optional.String) -  挑選
     * @param "Filter" (optional.String) -  過濾
     * @param "Orderby" (optional.String) -  排序
     * @param "Top" (optional.Int32) -  取前幾筆
     * @param "Skip" (optional.Int32) -  跳過前幾筆
@return ArrayOfCounty
*/

type BasicApiBasicGetCountyOpts struct {
    Select_ optional.String
    Filter optional.String
    Orderby optional.String
    Top optional.Int32
    Skip optional.Int32
}

func (a *BasicApiService) BasicGetCounty(ctx context.Context, format string, localVarOptionals *BasicApiBasicGetCountyOpts) (ArrayOfCounty, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ArrayOfCounty
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v2/Basic/County"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Select_.IsSet() {
		localVarQueryParams.Add("$select", parameterToString(localVarOptionals.Select_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Filter.IsSet() {
		localVarQueryParams.Add("$filter", parameterToString(localVarOptionals.Filter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Orderby.IsSet() {
		localVarQueryParams.Add("$orderby", parameterToString(localVarOptionals.Orderby.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Top.IsSet() {
		localVarQueryParams.Add("$top", parameterToString(localVarOptionals.Top.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Skip.IsSet() {
		localVarQueryParams.Add("$skip", parameterToString(localVarOptionals.Skip.Value(), ""))
	}
	localVarQueryParams.Add("$format", parameterToString(format, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ArrayOfCounty
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
BasicApiService 取得指定[縣市(County)]之鄉鎮市區列表
取得指定[縣市(County)]之鄉鎮市區列表&lt;br /&gt;  TownCode以內政部戶政司制定代碼之前7碼作為鄉鎮市區之唯一代碼。第8碼原則為0，完整8碼請至內政部戶政司網站( https://www.ris.gov.tw/app/portal/164 )戶役政資料代碼內容查詢。
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param county 縣市(英文)&lt;br&gt;Taipei &#x3D; 臺北市, &lt;br&gt;Taichung &#x3D; 臺中市, &lt;br&gt;Keelung &#x3D; 基隆市, &lt;br&gt;Tainan &#x3D; 臺南市, &lt;br&gt;Kaohsiung &#x3D; 高雄市, &lt;br&gt;NewTaipei &#x3D; 新北市, &lt;br&gt;YilanCounty &#x3D; 宜蘭縣, &lt;br&gt;Taoyuan &#x3D; 桃園市, &lt;br&gt;Chiayi &#x3D; 嘉義市, &lt;br&gt;HsinchuCounty &#x3D; 新竹縣, &lt;br&gt;MiaoliCounty &#x3D; 苗栗縣, &lt;br&gt;NantouCounty &#x3D; 南投縣, &lt;br&gt;ChanghuaCounty &#x3D; 彰化縣, &lt;br&gt;Hsinchu &#x3D; 新竹市, &lt;br&gt;YunlinCounty &#x3D; 雲林縣, &lt;br&gt;ChiayiCounty &#x3D; 嘉義縣, &lt;br&gt;PingtungCounty &#x3D; 屏東縣, &lt;br&gt;HualienCounty &#x3D; 花蓮縣, &lt;br&gt;TaitungCounty &#x3D; 臺東縣, &lt;br&gt;KinmenCounty &#x3D; 金門縣, &lt;br&gt;PenghuCounty &#x3D; 澎湖縣, &lt;br&gt;LienchiangCounty &#x3D; 連江縣
 * @param format 指定來源格式
 * @param optional nil or *BasicApiBasicGetCountyTownOpts - Optional Parameters:
     * @param "Select_" (optional.String) -  挑選
     * @param "Filter" (optional.String) -  過濾
     * @param "Orderby" (optional.String) -  排序
     * @param "Top" (optional.Int32) -  取前幾筆
     * @param "Skip" (optional.Int32) -  跳過前幾筆
@return ArrayOfCountyTown
*/

type BasicApiBasicGetCountyTownOpts struct {
    Select_ optional.String
    Filter optional.String
    Orderby optional.String
    Top optional.Int32
    Skip optional.Int32
}

func (a *BasicApiService) BasicGetCountyTown(ctx context.Context, county string, format string, localVarOptionals *BasicApiBasicGetCountyTownOpts) (ArrayOfCountyTown, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ArrayOfCountyTown
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v2/Basic/County/{County}/Town"
	localVarPath = strings.Replace(localVarPath, "{"+"County"+"}", fmt.Sprintf("%v", county), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Select_.IsSet() {
		localVarQueryParams.Add("$select", parameterToString(localVarOptionals.Select_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Filter.IsSet() {
		localVarQueryParams.Add("$filter", parameterToString(localVarOptionals.Filter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Orderby.IsSet() {
		localVarQueryParams.Add("$orderby", parameterToString(localVarOptionals.Orderby.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Top.IsSet() {
		localVarQueryParams.Add("$top", parameterToString(localVarOptionals.Top.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Skip.IsSet() {
		localVarQueryParams.Add("$skip", parameterToString(localVarOptionals.Skip.Value(), ""))
	}
	localVarQueryParams.Add("$format", parameterToString(format, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ArrayOfCountyTown
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
BasicApiService 取得指定[縣市(County)]之村里列表
取得指定[縣市(County)]之村里列表
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param county 縣市(英文)&lt;br&gt;Taipei &#x3D; 臺北市, &lt;br&gt;Taichung &#x3D; 臺中市, &lt;br&gt;Keelung &#x3D; 基隆市, &lt;br&gt;Tainan &#x3D; 臺南市, &lt;br&gt;Kaohsiung &#x3D; 高雄市, &lt;br&gt;NewTaipei &#x3D; 新北市, &lt;br&gt;YilanCounty &#x3D; 宜蘭縣, &lt;br&gt;Taoyuan &#x3D; 桃園市, &lt;br&gt;Chiayi &#x3D; 嘉義市, &lt;br&gt;HsinchuCounty &#x3D; 新竹縣, &lt;br&gt;MiaoliCounty &#x3D; 苗栗縣, &lt;br&gt;NantouCounty &#x3D; 南投縣, &lt;br&gt;ChanghuaCounty &#x3D; 彰化縣, &lt;br&gt;Hsinchu &#x3D; 新竹市, &lt;br&gt;YunlinCounty &#x3D; 雲林縣, &lt;br&gt;ChiayiCounty &#x3D; 嘉義縣, &lt;br&gt;PingtungCounty &#x3D; 屏東縣, &lt;br&gt;HualienCounty &#x3D; 花蓮縣, &lt;br&gt;TaitungCounty &#x3D; 臺東縣, &lt;br&gt;KinmenCounty &#x3D; 金門縣, &lt;br&gt;PenghuCounty &#x3D; 澎湖縣, &lt;br&gt;LienchiangCounty &#x3D; 連江縣
 * @param format 指定來源格式
 * @param optional nil or *BasicApiBasicGetCountyVillageOpts - Optional Parameters:
     * @param "Select_" (optional.String) -  挑選
     * @param "Filter" (optional.String) -  過濾
     * @param "Orderby" (optional.String) -  排序
     * @param "Top" (optional.Int32) -  取前幾筆
     * @param "Skip" (optional.Int32) -  跳過前幾筆
@return ArrayOfCountyVillage
*/

type BasicApiBasicGetCountyVillageOpts struct {
    Select_ optional.String
    Filter optional.String
    Orderby optional.String
    Top optional.Int32
    Skip optional.Int32
}

func (a *BasicApiService) BasicGetCountyVillage(ctx context.Context, county string, format string, localVarOptionals *BasicApiBasicGetCountyVillageOpts) (ArrayOfCountyVillage, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ArrayOfCountyVillage
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v2/Basic/County/{County}/Village"
	localVarPath = strings.Replace(localVarPath, "{"+"County"+"}", fmt.Sprintf("%v", county), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Select_.IsSet() {
		localVarQueryParams.Add("$select", parameterToString(localVarOptionals.Select_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Filter.IsSet() {
		localVarQueryParams.Add("$filter", parameterToString(localVarOptionals.Filter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Orderby.IsSet() {
		localVarQueryParams.Add("$orderby", parameterToString(localVarOptionals.Orderby.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Top.IsSet() {
		localVarQueryParams.Add("$top", parameterToString(localVarOptionals.Top.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Skip.IsSet() {
		localVarQueryParams.Add("$skip", parameterToString(localVarOptionals.Skip.Value(), ""))
	}
	localVarQueryParams.Add("$format", parameterToString(format, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json", "application/xml"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ArrayOfCountyVillage
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
